---
title: Análise de Sensores IoTs - Veracel
description: Análise de desempenho de dendrômetros IoTs para Veracel
author: 
  - name: João Saraiva
    affiliation: Equipe de Sustentação - Treevia Forest Technologies
date: last-modified
title-block-banner: true
title-block-banner-color: "#3D7A43"
bibliography: biblio.bib
execute: 
  echo: false
  warning: false
lang: "pt-br"
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
library(sf)
library(leaflet)
library(forecast)
library(plotly)
library(gt)
library(knitr)
library(htmltools)

source("R/utils.R")

options(scipen = 999)

data <- read_csv2("data/Inventario-SingleTrees -- Exportado - 24-07-2024 13-41.csv")

df <-
  data |> 
  mutate(across(c(Data_Plantio, Data_Medicao), dmy)) |> 
  filter(!Dap_Estimado)
```


## Distribuição espacial {#sec-geo}

A companhia Veracel Celulose, como cliente da Treevia Forest Technologies, possui atualmente `r length(unique(df$Plantio))` plantios e `r length(unique(df$Id_Amostra))` amostras operantes em seu projeto. A localização geográfica das amostras está demonstrada na @fig-map.

```{r}
#| label: fig-map
#| fig-cap: Distribuição das amostras - Veracel

points <- 
  data |> 
  count(Estrato, Amostra, Coordenada_X, Coordenada_Y) |> 
  st_as_sf(coords = c("Coordenada_X", "Coordenada_Y"))

labels <- sprintf(
  "Estrato: %s <br/> Amostra: %s <br/>X: %f<br/>Y: %f",
  points$Estrato,
  points$Amostra,
  st_coordinates(points$geometry)[, 1],
  st_coordinates(points$geometry)[, 2]
) |> lapply(htmltools::HTML)

leaflet(points) |> 
  addProviderTiles("Esri.WorldImagery") |> 
  addMarkers(label = labels)
```

## Periodicidade {#sec-period}

A fim de analisar a periodicidade dos dados dendrométricos coletados pelos sensores, os gráficos a seguir podem ser utilizados para observar as frequências segregadas por estrato. Visto que o período previsto de coleta é de três dias entre medições, é evidente que o estrato **`r unique(df$Estrato)[1]`** dispõe do comportamento mais anômalo em questão da frequência de coleta em campo. 

Entre outros estratos com comportamentos irregulares, estão:

- **`r unique(df$Estrato)[3]`**: a amostra 2522 possui a maioria de seus dados faltantes;
- **`r unique(df$Estrato)[13]`**: a amostra 10232628 possui uma grande quantidade de dados faltantes e uma mudança brusca em sua última medição;
- **`r unique(df$Estrato)[14]`**: a 10232614 possui uma grande quantidade de dados faltantes em suas primeiras medições;
- **`r unique(df$Estrato)[15]`**: a amostra 5 possui apenas 3 observações;
- **`r unique(df$Estrato)[16]`**: as amostra 8939, 8941 e 8942 possuem diversas medições faltantes antes de 19/04/2024 e a amostra 8938 possui apenas duas medições.


:::{.column-page}
:::{.panel-tabset}

```{r results='asis'}
#| warning: false
#| fig-cap: Evolução das medições por estrato

estratos <- unique(df$Estrato)

for(i in estratos) {
  cat("##", str_sub(i, 11), "\n\n\n")
  
  print(tagList(ggplotly(plot_estratos(df, i), tooltip = "text")))
  
  cat("\n\n")
}
```

:::
:::

## Datas irregulares {#sec-data}

A @tbl-dates demonstra os respectivos estratos, amostras e dispositivos onde foram coletadas medições com datas irregulares (ocorreram fora de 2024). As amostras problemáticas podem ser observadas nos gráficos da @sec-period.

:::{.column-body-outset}
```{r}
#| label: tbl-dates
#| tbl-cap: Datas irregulares

df |> 
  filter(year(Data_Medicao) != 2024) |> 
  group_by(Fazenda, Estrato, Amostra, MAC) |> 
  summarise(nliers = n()) |> 
  ungroup() |> 
  gt() |> 
  tab_pretty() |> 
  cols_label(nliers = "N° de Datas irregulares") |> 
  fmt_integer(use_seps = F)
```
:::

## Distribuição {#sec-distri}

Na @fig-boxdens, o boxplot mostra a distribuição dos DAPs das amostras em função dos estratos, enquanto o gráfico de densidade apresenta a distribuição contínua dos tempos de operação dos sensores.

Em sua grande maioria, os estratos se dispõem normalmente distribuídos, com alguns *outliers* pontuais visíveis. Já no gráfico de densidade, vê-se um comportamento normal com tendência a aproximadamente 150 dias de operação. Em contraposto, têm-se a presença de uma flutuação na densidade ao redor de 80 dias, o que indica uma troca de dendrômetros.

:::{.column-body-outset}
```{r}
#| label: fig-boxdens
#| fig-cap: Distribuição de DAP e de tempos de operação

box <-  
  df |> 
  filter(year(Data_Medicao) == 2024) |> 
  ggplot(aes(reorder(Estrato, `DAP (cm)`), `DAP (cm)`)) +
  geom_boxplot(color = "darkgreen", alpha = 0) +
  coord_flip() +
  theme_minimal() +
  labs(x = NULL)

box_ly <- ggplotly(box)
box_ly$x$data[[1]]$marker$line$color = "lightgreen"
box_ly$x$data[[1]]$marker$outliercolor = "lightgreen"
box_ly$x$data[[1]]$marker$color = "lightgreen"

idades <-
  df |>
  filter(year(Data_Medicao) == 2024) |>
  group_by(Estrato, Amostra, MAC) |>
  summarise(idade = as.numeric(max(Data_Medicao) - min(Data_Medicao)))

dens <-
  ggplot(idades) +
  geom_density(
    fill = "green",
    color = "darkgreen",
    alpha = 0.25,
    aes(
      x = idade,
      y = after_stat(density),
      text = sprintf(
        "Densidade: %.2f%%<br>Tempo de Operação do Sensor: %.2f dias",
        after_stat(density) * 100, x
      )
    )
  ) +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  labs(x = "Tempo de operação", y = "Densidade")

dens_ly <- ggplotly(dens, tooltip = "text")

subplot(box_ly, dens_ly,nrows = 1, margin = 0.05, titleX = T)
```

:::

## Outliers e Falhas {#sec-gap}

Os *gaps* e falhas operacionais são detectados a partir do agrupamento dos dados de medições por estratos e amostras. Os *gaps* são contabilizados por meio da contagem de lacunas maiores ou iguais a 4 dias nas séries temporais de cada amostra.

Os outliers são detectados utilizando a metodologia de análise de séries temporais descrita em @hyndman2021 para detecção de anomalias, implementada em linguagem R no pacote [`forecast`](https://pkg.robjhyndman.com/forecast/reference/tsoutliers.html). A @tbl-gaps demonstra os resultados:

:::{.column-body-outset}

```{r}
#| warning: false
#| tbl-cap: Outliers e gaps
#| label: tbl-gaps

gaps <-
  df |> 
  filter(year(Data_Medicao) == 2024) |> 
  group_by(Fazenda, Amostra) |> 
  arrange(Data_Medicao) |> 
  mutate(gap = as.numeric(Data_Medicao - lag(Data_Medicao)),
         is.gap = if_else(gap >= 4, T, F)) |> 
  summarise(gaps = sum(is.gap, na.rm = T))

liers <-
  df |>
  filter(year(Data_Medicao) == 2024) |>
  group_by(Fazenda, Amostra) |>
  arrange(`DAP (cm)`) |>
  summarise(nliers = length(tsoutliers(`DAP (cm)`)$index)) |>
  ungroup()

full_join(liers, gaps, by = c("Fazenda" = "Fazenda", "Amostra" = "Amostra")) |> 
  mutate(Fazenda = str_remove_all(Fazenda, c(" |_|-|[0-9]")),
         across(c(Amostra, Fazenda), as.factor)) |> 
  rename("N° de Outliers" = nliers, "N° de Gaps" = gaps) |> 
  DT::datatable(class = "cell-border stripe", 
                filter = list(position = "top", clear = F))
```

:::

Nota-se que os outliers temporais observados nesta seção são distinos dos citados na @sec-distri, já que àqueles são outliers **globais**, pois destoam da média dos DAPs, enquanto os outliers temporais são **contextuais**, ou seja, são valores anômalos apenas no contexto da tendência das séries temporais de medidas.

## Completude {#sec-complete}

A completude dos dados de coleta pode ser analisada por meio da @fig-complete, que indica o número de total de medições aferidas em cada estrato e o total de medições esperadas para o intervalo de coleta de três dias. Apesar da ausência de uma quantidade perceptível de dados, as coletas obtiveram um desempenho amplamente satisfatório.

::: {.column-body-outset}

```{r}
#| label: fig-complete
#| fig-cap: Número de medições reais e esperadas

indic <-
  df |> 
  filter(Data_Medicao >= "2024-05-01" & Data_Medicao <= today()) |> 
  group_by(Estrato, Amostra) |> 
  summarise(
    medicoes = n(),
    esperado = round(as.numeric(today() - min(Data_Medicao))/3)
  ) |> 
  ungroup()
  
bars <-
  indic |> 
  summarise(
    .by = Estrato, 
    real = sum(medicoes), 
    exp = sum(esperado)
  ) |> 
  rename("Esperado" = exp, "Real" = real) |> 
  pivot_longer(-Estrato) |>
  ggplot(aes(value, reorder(Estrato, value), fill = name)) +
  geom_col(
    position = "dodge",
    alpha = 0.75,
    aes(text = sprintf("%s<br>N° de Medições: %d", name, value))
  ) +
  labs(fill = NULL, x = "N° de Medições", y = NULL) +
  scale_fill_manual(values = c("lightgreen", "darkgreen")) +
  theme_minimal()

bar_ly <- ggplotly(bars, tooltip = "text")

bar_ly
```

:::

