---
title: Análise de Sensores IoTs - Veracel
description: Análise de desempenho de dendrômetros IoTs para Veracel
author: 
  - name: Equipe de Sustentação
    affiliation: Treevia Forest Technologies
date: last-modified
title-block-banner: true
title-block-banner-color: "#3D7A43"
format: 
  html:
    embed-resources: true
    smooth-scroll: true
    theme: cosmo
    fontcolor: black
    toc: true
    toc-location: left
    toc-title: Sumário
    toc-depth: 2
css: styles.css
bibliography: biblio.bib
execute: 
  echo: false
  warning: false
lang: "pt-br"
editor_options: 
  chunk_output_type: console
---

```{r}
library(tidyverse)
library(sf)
library(leaflet)
library(forecast)
library(plotly)
library(gt)
library(knitr)
library(htmltools)

source("utils.R")

options(scipen = 999)

data <- read_csv2("data/Inventario-SingleTrees -- Exportado - 24-07-2024 13-41.csv")

df <-
  data |> 
  mutate(across(c(Data_Plantio, Data_Medicao), dmy)) |> 
  filter(!Dap_Estimado)
```


## Distribuição espacial

A companhia Veracel Celulose, como cliente da Treevia Forest Technologies, possui atualmente `r length(unique(df$Plantio))` plantios e `r length(unique(df$Id_Amostra))` amostras operantes em seu projeto. A localização geográfica das amostras está demonstrada na @fig-map.

```{r}
#| label: fig-map
#| fig-cap: Distribuição das amostras - Veracel

points <- 
  data |> 
  count(Estrato, Amostra, Coordenada_X, Coordenada_Y) |> 
  st_as_sf(coords = c("Coordenada_X", "Coordenada_Y"))

labels <- sprintf(
  "Estrato: %s <br/> Amostra: %s <br/>X: %f<br/>Y: %f",
  points$Estrato,
  points$Amostra,
  st_coordinates(points$geometry)[, 1],
  st_coordinates(points$geometry)[, 2]
) |> lapply(htmltools::HTML)

leaflet(points) |> 
  addProviderTiles("Esri.WorldImagery") |> 
  addMarkers(label = labels)
```

## Periodicidade {#sec-period}

A fim de analisar a periodicidade dos dados dendrométricos coletados pelos sensores, os gráficos a seguir podem ser utilizados para observar as frequências segregadas por estrato. Visto que o período previsto de coleta é de três dias entre medições, é evidente que o estrato **`r unique(df$Estrato)[1]`** dispõe do comportamento mais anômalo em questão da frequência de coleta em campo. 

Entre outros estratos com comportamentos irregulares, estão:

- **`r unique(df$Estrato)[3]`**: a amostra 2522 está tem uma maioria de dados faltantes;
- **`r unique(df$Estrato)[13]`**: a amostra 10232628 possui uma grande quantidade de dados faltantes e uma mudança brusca em sua última medição;
- **`r unique(df$Estrato)[14]`**: a 10232614 possui uma grande quantidade de dados faltantes em suas primeiras medições;
- **`r unique(df$Estrato)[15]`**: a amostra 5 possui apenas 3 observações;
- **`r unique(df$Estrato)[16]`**: as amostra 8939, 8941 e 8942 possui diversas medições faltantes antes de 19/04/2024 e a amostra 8938 possui apenas duas medições.


:::{.column-page}
:::{.panel-tabset}

```{r results='asis'}
#| warning: false
#| fig-cap: Evolução das medições por estrato

estratos <- unique(df$Estrato)

for(i in estratos) {
  cat("##",i, "\n\n\n")
  
  print(tagList(ggplotly(plot_estratos(df, i), tooltip = "text")))
  
  cat("\n\n")
}
```

:::
:::

## Datas irregulares

A @tbl-dates demonstra os estratos, amostras e respectivos dispositivos com medições com datas de medições irregulares (ocorreram fora de 2024). As amostras com problemáticas podem ser observadas nos gráficos da @sec-period.

:::{.column-body-outset}
```{r}
#| label: tbl-dates
#| tbl-cap: Datas irregulares

df |> 
  filter(year(Data_Medicao) != 2024) |> 
  group_by(Fazenda, Estrato, Amostra, MAC) |> 
  summarise(nliers = n()) |> 
  ungroup() |> 
  gt() |> 
  tab_pretty() |> 
  cols_label(nliers = "N° de Datas irregulares") |> 
  fmt_integer(use_seps = F)
```
:::

## Outliers e Falhas

Os *gaps* e falhas operacionais são detectados são detectados a partir do agrupamento dos dados de medições por estratos e amostras. Os *gaps* são contabilizados por meio da contagem de lacunas maiores ou iguais a 4 dias nas séries temporais de cada amostra.

Os *outliers* são detectados utilizando a metodologia de análise de séries temporais descrita em @hyndman2021 para detecção de anomalias, implementada em linguagem R no pacote [`forecast`](https://pkg.robjhyndman.com/forecast/reference/tsoutliers.html). A @tbl-gaps demonstra os resultados:

:::{.column-body-outset}

```{r}
#| warning: false
#| tbl-cap: Outliers e gaps
#| label: tbl-gaps

gaps <-
  df |> 
  filter(year(Data_Medicao) == 2024) |> 
  group_by(Estrato, Amostra) |> 
  arrange(Data_Medicao) |> 
  mutate(gap = as.numeric(Data_Medicao - lag(Data_Medicao)),
         is.gap = if_else(gap >= 4, T, F)) |> 
  summarise(gaps = sum(is.gap, na.rm = T))

liers <-
  df |>
  filter(year(Data_Medicao) == 2024) |>
  group_by(Estrato, Amostra) |>
  arrange(`DAP (cm)`) |>
  summarise(nliers = length(tsoutliers(`DAP (cm)`)$index)) |>
  ungroup()

full_join(liers, gaps, by = c("Estrato" = "Estrato", "Amostra" = "Amostra")) |> 
  mutate(across(c(Amostra, Estrato), as.factor)) |> 
  rename("N° de Outliers" = nliers, "N° de Gaps" = gaps) |> 
  DT::datatable(class = "cell-border stripe", 
                filter = list(position = "top", clear = F))
```

:::

::: {.column-body-outset}

```{r}
idades <-   
  df |> 
  filter(year(Data_Medicao) == 2024) |> 
  group_by(Estrato, Amostra, MAC) |> 
  summarise(idade = as.numeric(max(Data_Medicao) - min(Data_Medicao)))

dens <-
  ggplot(idades) +
  geom_density(
    fill = "green",
    color = "darkgreen",
    alpha = 0.25,
    aes(
      x = idade,
      y = after_stat(density),
      text = sprintf("Densidade: %.2f%%<br>Idade: %.2f dias",
                     after_stat(density) * 100, x)
    )
  ) +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  labs(x = "Tempo de operação", y = "Densidade")

dens_ly <- ggplotly(dens, tooltip = "text")

df |> 
  filter(year(Data_Medicao) == 2024,
         Data_Medicao > "2024-05-01" & Data_Medicao < today()) 
  

idade_ly <- ggplotly(idades_med, tooltip = "text")

subplot(idade_ly, dens_ly, nrows = 1, margin = 0.07)
```
:::
